	WHEN TO APPLY DYNAMMIC PROGRAMMING->
	1.when you are given choices and you are asked to find something optimal.
	2.the greedy approach will fail when there in non uniformity or randomness in testcases.


	RECURRENCE RELATION->
	TO WRITE 1D recurrence relation do the following steps->
	1.express the problem in terms of index.
	2.do all possible stuffs on the index according to the question.
	3.return the thing that the problem is asking for.
	4.when writing base case always assume that you have an array containing a single element.

	SPACE OPTIMISATION->
	IF THERE IS SOMETHING LIKE index-1 OR index-2 THEN THERE CAN BE ALWAYS SPACE OPTIMISATION.
	1D optimised to some varibles.
	2D optimised to 1D.
	3D optimised to 2D.

	DIFFERENCE BETWEEN TABULATION AND MEMOISATION->
	tabulation is bottom up i.e. we start from the bottom(base case) and go to the top to find our answer.
	memoisation is top down i.e. we start from the top the hit the base case and then again come to top to get the answer.
	
	
	TABULATION->
	1.declare the dp array of same size as declared in memoisation.
	2.base case becomes initialisation.
	3.whatever you write for recursion , write the opposite for tabulation i.e the direction of loops will become opposite i.e. run for loops in opposite direction for changing parameters.
	4.In memoisation and tabulation, we declare the space same as that of changing parameters i.e. if there is 1 changing parameter ,then make 1d array. If there are 2 changing parameters then make 2d array.
	5.copy the recurrence.
	6.instead of the function name in memoisation, replace that with dp in tabulation.
	7.number of changing states in memoisation = number of nested loops in tabulation. 
	8.bottom up means from base case to up.
	9.top down means from up to base case and then after computing the answer from base case,we get the answer for top. 
	STEPS->
	A.Initialise the base case.
	B.Run the for loops on the changing states in opposite fashion.
	C.Copy the recurrence.

	Important patterns->
	1.Dp on grids -> parent problem-> MINIMUM PATH SUM.
	2.Dp on subsequences -> parent problem-> SUBSET SUM EQUALS TARGET.
	3. Dp on strings -> parent problem-> LONGEST COMMON SUBSEQUNCE.
